<!DOCTYPE html>
<html>
<head>
    <title>ASL Recognition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px;
            text-align: center;
        }
        video { 
            width: 640px; 
            height: 480px; 
            border: 2px solid #333;
            margin-bottom: 10px;
        }
        #canvas { display: none; }
        button { 
            padding: 10px 20px; 
            margin: 10px; 
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #status, #prediction, #debug { 
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f8f8;
        }
        #status { color: #0066cc; }
        #prediction { 
            color: #009900; 
            font-weight: bold;
            font-size: 20px;
        }
        #debug {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>ASL Gesture Recognition</h1>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
    <br>
    <button id="recordBtn">Start Recording</button>
    <div id="status">Ready to record</div>
    <div id="prediction">No prediction yet</div>
    <div id="debug">Debug information will appear here</div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const recordBtn = document.getElementById('recordBtn');
        const statusDiv = document.getElementById('status');
        const predictionDiv = document.getElementById('prediction');
        const debugDiv = document.getElementById('debug');
        
        let recording = false;
        let frames = [];
        const socket = io('http://localhost:8080');
        
        // Debug logging function
        function log(message) {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 640 }, 
                height: { ideal: 480 },
                frameRate: { ideal: 10, max: 15 }
            } 
        }).then(stream => {
            video.srcObject = stream;
            canvas.width = 640;
            canvas.height = 480;
            log(`Camera initialized: ${canvas.width}x${canvas.height}`);
        }).catch(err => {
            log(`Error accessing webcam: ${err.message}`);
            statusDiv.textContent = `Error: ${err.message}`;
        });

        socket.on('connect', () => {
            log('Connected to server');
            statusDiv.textContent = 'Connected to server';
        });

        socket.on('connect_error', (error) => {
            log(`Connection error: ${error.message}`);
            statusDiv.textContent = `Connection error: ${error.message}`;
        });

        socket.on('prediction', (data) => {
            log(`Received prediction: ${JSON.stringify(data)}`);
            if (data.error) {
                predictionDiv.textContent = `Error: ${data.result}`;
                predictionDiv.style.color = '#cc0000';
            } else {
                predictionDiv.textContent = `Recognized Gesture: ${data.result}`;
                predictionDiv.style.color = '#009900';
            }
            statusDiv.textContent = 'Processing complete';
            recordBtn.disabled = false;
        });

        recordBtn.addEventListener('click', () => {
            if (!recording) {
                recording = true;
                frames = [];
                recordBtn.textContent = 'Stop Recording';
                statusDiv.textContent = 'Recording...';
                log('Started recording');
                recordFrames();
            } else {
                recording = false;
                recordBtn.textContent = 'Start Recording';
                statusDiv.textContent = 'Sending to server...';
                log(`Stopped recording. Captured ${frames.length} frames`);
                recordBtn.disabled = true;
                sendFrames();
            }
        });

        function recordFrames() {
            if (recording) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const frameData = canvas.toDataURL('image/jpeg', 0.7);
                frames.push(frameData);
                
                if (frames.length % 10 === 0) {
                    log(`Captured ${frames.length} frames`);
                }
                
                if (frames.length >= 60) {  // Reduced from 120 to 60 for faster processing
                    recording = false;
                    recordBtn.textContent = 'Start Recording';
                    statusDiv.textContent = 'Sending to server...';
                    log(`Max frames reached. Captured ${frames.length} frames`);
                    recordBtn.disabled = true;
                    sendFrames();
                } else {
                    // Continue capturing frames at about 10fps
                    setTimeout(recordFrames, 100);
                }
            }
        }

        function sendFrames() {
            // If we have too many frames, sample them to reduce data size
            if (frames.length > 30) {
                log(`Sampling frames from ${frames.length} to 30`);
                const sampledFrames = [];
                const step = Math.floor(frames.length / 30);
                for (let i = 0; i < frames.length; i += step) {
                    sampledFrames.push(frames[Math.min(i, frames.length - 1)]);
                }
                frames = sampledFrames;
            }
            
            log(`Sending ${frames.length} frames to server`);
            
            // Calculate approximate data size
            let totalSize = 0;
            frames.forEach(frame => totalSize += frame.length);
            log(`Approximate data size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
            
            // First frame sample for debugging
            if (frames.length > 0) {
                log(`First frame sample: ${frames[0].substring(0, 50)}...`);
            }
            
            socket.emit('video_frames', { frames: frames });
            
            // Add timeout to detect if server doesn't respond
            setTimeout(() => {
                if (statusDiv.textContent === 'Sending to server...' || 
                    statusDiv.textContent === 'Processing...') {
                    statusDiv.textContent = 'Server did not respond within 30 seconds';
                    log('Timeout: Server did not respond within 30 seconds');
                    recordBtn.disabled = false;
                }
            }, 30000);
        }
    </script>
</body>
</html>
